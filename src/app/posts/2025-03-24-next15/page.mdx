export const metadata = {
  title: "Migrating to Next.js 15",
  description: "Blog post about migrating to Next.js 15",
  date: "2025-03-24",
  draft: true,
  categories: ["JS"],
};

After 8 years, last year I finally made the jump and migrated off of my legacy Jekyll blog and onto NextJS. Dmitry, of Reshaped fame, had made a NextJS template that was inspired by Brian Lovin blog and I was excited to adopt both a modern stack and design ([post](/2024-02-19-migrating-to-next)).

After a year, some of the cracks were beginning to show. The most important was page load time. Because the site was server rendered, and not staticly built, each page could take a couple of seconds to load.

There were also some small details as well.

- If you tried to load the dark theme during the day, you'd see the light theme flash. Worse, if you set the light theme at night, you'd see the dark theme flash.
- Because the layout had two sidebars, the content was never centered unless you entered a reader mode which added an additional click.
- And because at the time, NextJS did not have first class support for MDX, the site used `MDXRemote` and rendered the markdown on demand which added complexity.

And while none of these issues were by themselves insurmountable, it felt like it would be easier to make the jump to Next 15 and adopt first class MDX support.

There was also the added benefit of being able to borrow ideas from [Lee Robinson](https://x.com/leeerob), Vercel's head of product, and [Guillermo Rauch](https://x.com/rauchg), Vercel's CEO, who both had modern setups.

### Here are some of the lessons



### Adding a post header

On the surface, Guillermo and Lee have similar setups. They both use `@next/mdx` which makes it really easy to add `mdx` pages.

```ts
import createMDX from "@next/mdx";

/** @type {import('next').NextConfig} */
const nextConfig = {
  pageExtensions: ["md", "mdx", "ts", "tsx"],
  experimental: {},
};

const withMDX = createMDX({});
export default withMDX(nextConfig);
```



Because Lee just shows the post's title, he's able to include in the markdown and move on. Because, Guillermo includes the date the post was published and view count, he needs to fetch the data separately.

At the most simple level, he does what you'd expect and fetches the post details and page count from an API endpoint which queries redis on page load. Because this is async and would cause a page flash, he also keeps a static list of posts which he uses during the server render and static build phase.

This is fine, and it may just by my OCD speaking, but I find having to keep the JSON file in sync, a bit ugly. Sure, you could add a watch command to build the JSON file in the background, but simply maintaining an extra artifact in your repo feels wrong.

```bash
"concurrently \"next dev --turbopack\" \"bun run watch-posts\"",`
```



The work around, is to have the post's `layout` component fetch the posts and pass them down to the Header component.

```tsx
export default async function BlogLayout({ children}: {children: React.ReactNode}) {
  const posts = await getBlogPosts();
  return (
    <div>
      <Header posts={posts} />
      {children}
    </div>
  );
}
```



This is almost exactly what you want, but it still has one disadvantage. Because we're passing all of the posts down to client, just to find the one that matches the current post's slug, we're sending far more data to the client than is needed. 

```tsx
export default function Header({ posts }: { posts: PostWithoutContent[] }) {
  const pathname = usePathname();
  const post = posts.find((p) => pathname.endsWith(p.slug));
  return <h1>{post.title} (post.date)</h1>
}
```



While this is not worse than what we were doing before with the `posts.json` file, it is unfortunate because it feels like something that should be handled in the server component and thus avoidable. 

The rationale is that by not including path information, the server component, is able to preserve state across navigations, which is nice, but does have this downside.



### Should metadata be Yaml or JS?

MDX became popular because it lets you import your own components and Next components like `Image`  . It also lets you export constants like `metadata` which works similar to page metadata.

```js
export const metadata = {
  title: 'Understanding AI',
  description: 'A brief overview on neural networks and language models.',
  alternates: {
    canonical: '/n/ai'
  },
  openGraph: {
    title: "Understanding AI",
    description: "A brief overview on neural networks and language models.",
    images: [{ url: '/og/7-principles-of-rich-web-applications' }],
  }
};
```



This is a nice improvement over the classical frontmatter approach where you're including YAML at the top of the post which is how one of Vercel's [demo blogs](https://github.com/vercel/examples/tree/main/solutions/blog ) handles it.

```yaml 
---
title: Understanding AI
description: A brief overview on neural networks and language models.
---
```



The one downside is being able to easily collect the post metadata for the sitemap and posts list. The  demo site collects the metadata by reading the files and parsing the YAML which is not too hard since the format is simple, but somewhat ugly.

```  js
function parseFrontmatter(fileContent: string) {
  let frontmatterRegex = /---\s*([\s\S]*?)\s*---/
  let match = frontmatterRegex.exec(fileContent)
  let frontMatterBlock = match![1]
  let content = fileContent.replace(frontmatterRegex, '').trim()
  let frontMatterLines = frontMatterBlock.trim().split('\n')
  let metadata: Partial<Metadata> = {}

  frontMatterLines.forEach((line) => {
    let [key, ...valueArr] = line.split(': ')
    let value = valueArr.join(': ').trim()
    value = value.replace(/^['"](.*)['"]$/, '$1') // Remove quotes
    metadata[key.trim() as keyof Metadata] = value
  })

  return { metadata: metadata as Metadata, content }
}

function getMDXData(dir) {
  let mdxFiles = getMDXFiles(dir)
  return mdxFiles.map((file) => {
    let { metadata, content } = readMDXFile(path.join(dir, file))
    let slug = path.basename(file, path.extname(file))

    return {
      metadata,
      slug,
      content,
    }
  })
}

```



On the surface, this should be an advantage of the module approach because you should be able to 





```js 
export function extractMetadata(filePath: string): Metadata {
  const content = fs.readFileSync(filePath, 'utf-8');
  const metadataMatch = content.match(/export const metadata = ({[\s\S]*?});/);

  if (metadataMatch && metadataMatch[1]) {
    try {
      // Use eval in a safer way by executing in a controlled scope
      const evalFn = new Function(`
        try {
          const metadata = ${metadataMatch[1]};
          return JSON.stringify(metadata);
        } catch (e) {
          return '{"error": "Failed to evaluate metadata: " + e.message}';
        }
      `);

      const jsonStr = evalFn();
      const metadata = JSON.parse(jsonStr);

      if (metadata.error) {
        console.error(metadata.error);
        return {
          title: 'Error',
          publishedAt: new Date().toISOString(),
          summary: '',
        };
      }

      return standardizeMetadata(metadata);
    } catch (error) {
      console.error(`Error processing metadata from ${filePath}: ${error instanceof Error ? error.message : 'Unknown error'}`);
      console.error(`Original metadata: ${metadataMatch[1]}`);
      return {
        title: 'Error',
        publishedAt: new Date().toISOString(),
        summary: '',
      };
    }
  }
  return {
    title: 'No Metadata',
    publishedAt: new Date().toISOString(),
    summary: '',
  };
}

```







Topics

- NextJS MDX support vs remote content
- Post metadata (export vs frontmatter)
- Page performance
- Adopting RauchG's layout
- AI changed the titles
